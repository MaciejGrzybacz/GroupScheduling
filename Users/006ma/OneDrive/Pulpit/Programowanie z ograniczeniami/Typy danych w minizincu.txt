Typy danych w minizincu:
1. typy liczbowe
	- int: Reprezentuje liczby całkowite (integer). To podstawowy typ danych 	liczbowych w MiniZinc. (var int: liczba_calkowita = 42;)
	- float: Reprezentuje liczby rzeczywiste (zmiennoprzecinkowe). Używane do 	modelowania wartości zmiennoprzecinkowych. (var float: liczba_rzeczywista = 	3.14;)
2. typ logiczny
	- bool: reprezentuje wartości logiczne(var bool: warunek = true;)
3.  string
	- string: Reprezentuje ciągi znaków (łańcuchy). Używane do przechowywania 	tekstowych danych. (var string: imie = "Jan Kowalski";)
4. zbiór
	- set of int: Reprezentuje zbiór liczb całkowitych. Używane do definiowania 	zbiorów elementów.(var set of int: zbior_liczb = {1, 2, 3, 4, 5};)
5. tablica
	-array: Tablice są używane do przechowywania sekwencji elementów. Mogą być 	tablice jedno- lub wielowymiarowe i zawierać elementy dowolnego typu danych.
	(array[1..5] of int: tablica_liczb = [1, 2, 3, 4, 5];
	array[1..3, "A".."C"] of float: tablica_2d;)
6. funkje i predykaty
	-W MiniZinc można definiować własne funkcje i predykaty, które pozwalają na 	tworzenie niestandardowych ograniczeń i obliczeń.
	(function int: moja_funkcja(int: x, int: y) = x + y;
	predicate czy_rowne(int: x, int: y) = x == y;)

================================================================================ 

Operacje sterujące w minizincu:
Nie istnieją pętle w znaczeniu z innych języków programowania, odpowiednik for to rekurencyjne wywoływanie funkcji/predykatu
(predicate print_numbers(var int: n) =
    if n >= 1 then
        print(n);
        print_numbers(n - 1);
    else
        true
    endif;

constraint print_numbers(10); )
Można też użyć forall
(var int: n = 10;
array[1..n] of var int: numbers = [i | i in 1..n];

constraint forall(i in 1..n)(output(["Number ", show(i), ": ", show(numbers[i])]));)

------------------------------------------------------------------- 

If else wygląda tak:
if <warunek> then
    % Kod do wykonania, jeśli warunek jest prawdziwy
else
    % Kod do wykonania, jeśli warunek nie jest prawdziwy
endif;
var int: x = 10;

Gdy mamy więcej warunków:
if x > 5 then
    output["x jest większe niż 5\n"];
else if x == 5 then
    output["x jest równe 5\n"];
else
    output["x jest mniejsze niż 5\n"];
endif;

===================================================================================

Struktura programu w języku MiniZinc jest podobna do innych języków programowania, ale z uwzględnieniem specyfiki języka do rozwiązywania problemów optymalizacyjnych i konstrukcji modeli matematycznych. Oto ogólna struktura programu w MiniZinc:

1. Deklaracje zmiennych i parametrów:

	Rozpocznij program od deklaracji zmiennych i parametrów, które będą używane 	w Twoim modelu. Możesz zadeklarować zmienne liczbowe, tablice, parametry 	oraz zbiory, w zależności od potrzeb Twojego modelu.

   	Przykład deklaracji:

   	var int: x;             % Zmienna całkowita
   	array[1..5] of int: arr; % Tablica liczb całkowitych
   	int: param = 10;        % Parametr
   	set of int: set_param = {1, 2, 3};  % Zbiór liczb całkowitych

2. Deklaracje funkcji i predykatów (opcjonalne):

   	Jeśli Twoje rozwiązanie wymaga zdefiniowania własnych funkcji lub 	predykatów, możesz to zrobić w tym kroku. Funkcje i predykaty mogą pomóc w 	organizacji kodu i wyrażaniu bardziej skomplikowanych zależności.

   	Przykład deklaracji funkcji:

   	function int: add(int: a, int: b) = a + b;

3. Definicje ograniczeń:

   	W tej części programu określasz ograniczenia, które muszą być spełnione w 	rozwiązaniu problemu. Możesz użyć różnych operatorów logicznych do 	wyrażenia tych ograniczeń.

   	Przykład definicji ograniczeń:

   	constraint x > 0;
   	constraint forall(i in 1..5)(arr[i] >= 0);

4. Definicja celu rozwiązania (opcjonalne):

   	Jeśli Twój problem jest problemem optymalizacyjnym, zdefiniuj cel, który ma 	zostać osiągnięty. Możesz użyć `solve maximize` lub `solve minimize` do 	określenia, czy dążysz do maksymalizacji czy minimalizacji wartości celu.

   	Przykład definicji celu:

   	solve maximize add(x, param);

5. Definicje wyjścia (opcjonalne):

   	Jeśli chcesz wyświetlić wyniki po rozwiązaniu problemu, możesz zdefiniować, 	jakie informacje mają zostać wyświetlone jako wynik. To często obejmuje 	wyjście wartości zmiennych lub wyników funkcji.

   	Przykład definicji wyjścia:

   	output ["x = ", show(x), "\n"];

6. Przykłady danych wejściowych:

  	 Możesz dostarczyć przykłady danych wejściowych (data) w osobnych plikach 	lub bezpośrednio w kodzie. Przykłady te pomagają w testowaniu i 	rozwiązywaniu problemu.

   	Przykład definicji danych wejściowych:

   	include "example_data.dzn";
===================================================================================
Przydatne funkcje w MiniZinc:
1. Na liczbach 
	1. abs(x): Zwraca wartość bezwzględną liczby x.

	2. min(x, y): Zwraca mniejszą z dwóch liczb x i y.

	3.max(x, y): Zwraca większą z dwóch liczb x i y.

	4. sqrt(x): Oblicza pierwiastek kwadratowy z liczby x.

	5. ln(x): Oblicza naturalny logarytm liczby x.

	6. log2(x): Oblicza logarytm o podstawie 2 z liczby x.

	7. log10(x): Oblicza logarytm o podstawie 10 z liczby x.

	8. exp(x): Oblicza wykładnik liczby x.

	9. sin(x): Oblicza sinus liczby x.

	10. cos(x): Oblicza cosinus liczby x.

	11. tan(x): Oblicza tangens liczby x.

2. Na tablicach
	1. `length(arr)`: Zwraca długość tablicy.

	2. `array1 ++ array2`: Łączy dwie tablice.

	3. `array1 union array2`: Zwraca unię dwóch tablic.

	4. `array1 diff array2`: Zwraca różnicę dwóch tablic.

	5. `array1 ++ [element]`: Dodaje element na koniec tablicy.

	6. `array1 + array2`: Dodaje dwie tablice razem.

	7. `array1[index]`: Pobiera element z tablicy na podstawie indeksu.

	8. `array1[index1..index2]`: Pobiera podtablicę od index1 do index2.

	9. `min(array)`: Zwraca minimalną wartość w tablicy.

	10. `max(array)`: Zwraca maksymalną wartość w tablicy.

	11. `sum(array)`: Sumuje wszystkie elementy w tablicy.

	12. `sort(array)`: Sortuje elementy w tablicy.

	13. `reverse(array)`: Odwraca kolejność elementów w tablicy.

	14. `exists(element in array)`: Sprawdza, czy element istnieje w tablicy.

	15. `forall(element in array)`: Sprawdza, czy wszystkie elementy spełniają pewien warunek.

	16. `array1 == array2`: Porównuje dwie tablice pod kątem równości.

	17. `array[index] = value`: Przypisuje nową wartość do elementu tablicy.

	18. `array[index] != value`: Sprawdza, czy element tablicy nie jest równy danej wartości.

	19. `array[1..n]`: Tworzy tablicę elementów od 1 do n.

	20. `array[index] in set`: Sprawdza, czy element tablicy należy do określonego zbioru.

3. Na stringach
	1. `length(s)`: Zwraca długość ciągu znaków `s`.

	2. `concat(s1, s2)`: Łączy dwa ciągi znaków `s1` i `s2` w jeden ciąg.

	3. `substr(s, start, length)`: Zwraca fragment ciągu znaków `s`, zaczynając od pozycji `start` i mający długość `length`.

	4. `replace(s, pattern, replacement)`: Zamienia wszystkie wystąpienia wzorca `pattern` na ciąg znaków `replacement` w ciągu `s`.

	5. `contains(s, substring)`: Sprawdza, czy ciąg `s` zawiera podciąg `substring`.

	6. `index(s, substring)`: Znajduje pozycję pierwszego wystąpienia podciągu `substring` w ciągu `s`.

	7. `to_upper(s)`: Konwertuje wszystkie litery w ciągu `s` na wielkie litery.

	8. `to_lower(s)`: Konwertuje wszystkie litery w ciągu `s` na małe litery.

	9. `trim(s)`: Usuwa białe znaki (spacje, tabulatory itp.) z początku i końca ciągu `s`.

	10. `split(s, delimiter)`: Dzieli ciąg `s` na tablicę podciągów, używając `delimiter` jako separatora.

	11. `join(strings, delimiter)`: Łączy tablicę ciągów `strings` w jeden ciąg, oddzielając je znakiem `delimiter`.

	12. `startswith(s, prefix)`: Sprawdza, czy ciąg `s` zaczyna się od podciągu `prefix`.

	13. `endswith(s, suffix)`: Sprawdza, czy ciąg `s` kończy się podciągiem `suffix`.

	14. `isdigit(s)`: Sprawdza, czy wszystkie znaki w ciągu `s` są cyframi.

	15. `isalpha(s)`: Sprawdza, czy wszystkie znaki w ciągu `s` są literami.

	16. `isalnum(s)`: Sprawdza, czy wszystkie znaki w ciągu `s` są literami lub cyframi.

	17. `isspace(s)`: Sprawdza, czy wszystkie znaki w ciągu `s` są białymi znakami.

	18. `count(s, substring)`: Liczy wystąpienia podciągu `substring` w ciągu `s`.

	19. `reverse(s)`: Odwraca kolejność znaków w ciągu `s`.

	20. `format(fmt, args)`: Formatuje ciąg znaków używając wzorca `fmt` i argumentów `args`.

==========================================================================================









